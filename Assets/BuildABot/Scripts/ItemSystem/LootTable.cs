using System;
using System.Collections.Generic;
using UnityEngine;
using Random = UnityEngine.Random;

namespace BuildABot
{
    /**
     * A loot table used to determine drops by enemy NPCs or container loot.
     */
    [CreateAssetMenu(fileName = "NewLootTable", menuName = "Build-A-Bot/Loot Table", order = 1)]
    public class LootTable : ScriptableObject
    {

        /**
         * An entry in a loot table.
         * <summary>
         * A entry in the loot table. Each entry is associated with a specific item and determines the rate
         * that that item will be spawned by the loot table. If the item is selected when generating a collection
         * from the table then the number spawned will be randomly determined by the minimum and maximum counts
         * specified in this entry.
         * </summary>
         */
        [Serializable]
        public class LootTableEntry
        {
            [Tooltip("The item associated with this entry. This does not have to be unique within entries.")]
            [SerializeField] private Item item;
            
            [Tooltip("The chance that the item of this entry will be spawned. Percentage as a 0-1 value.")]
            [Range(0.0f, 1.0f)]
            [SerializeField] private float dropChance;

            [Tooltip("The minimum possible number of this item spawned if this entry is selected.")]
            [Min(0)]
            [SerializeField] private int minSpawned = 0;
            
            [Tooltip("The maximum possible number of this item spawned if this entry is selected.")]
            [Min(1)]
            [SerializeField] private int maxSpawned = 0;

            [Tooltip("The average durability percentage generated for parts spawned from this entry.")]
            [Range(0.0f, 1.0f)]
            [SerializeField] private float averageDurability = 0.5f;

            [Tooltip("The durability standard deviation percentage generated for parts spawned from this entry.")]
            [Range(0.0f, 1.0f)]
            [SerializeField] private float durabilityDeviation = 0.5f;
            
            /** The item associated with this entry. */
            public Item Item => item;
            /** The chance that the item of this entry will be spawned. */
            public float DropChance => dropChance;

            /** The minimum count of this entry's item that will spawn if this entry is selected. */
            public int MinSpawned => minSpawned;
            /** The maximum count of this entry's item that will spawn if this entry is selected. */
            public int MaxSpawned => maxSpawned;

            /** The average durability percentage for parts generated by this entry. */
            public float AverageDurability => averageDurability;

            /** The durability standard deviation percentage generated for parts spawned from this entry. */
            public float DurabilityDeviation => durabilityDeviation;
        }
        
        [Tooltip("The item entries of this loot table.")]
        [SerializeField] private List<LootTableEntry> entries;

        /**
         * Generates a random list of inventory entries from this loot table.
         * <returns>A list of inventory item entries generated from this loot table.</returns>
         */
        public List<InventoryEntry> GenerateItemList()
        {
            List<InventoryEntry> result = new List<InventoryEntry>();
            foreach (LootTableEntry entry in entries)
            {
                if (Random.Range(0.0f, 1.0f) <= entry.DropChance)
                {
                    // Chosen to spawn, generate count and add to list

                    int count = Random.Range(entry.MinSpawned, entry.MaxSpawned + 1);

                    switch (entry.Item)
                    {
                        case StackableItem s: // Any stackable type
                            result.Add(new ItemStack(s, count));
                            break;
                        case ComputerPartItem c: // Computer part
                        {
                            for (int i = 0; i < count; i++)
                            {
                                // Calculate the durability value to generate
                                int minDurability = Mathf.FloorToInt(c.MaxDurability * Mathf.Clamp01(entry.AverageDurability - entry.DurabilityDeviation));
                                int maxDurability = Mathf.FloorToInt(c.MaxDurability * Mathf.Clamp01(entry.AverageDurability + entry.DurabilityDeviation));
                                result.Add(ComputerPartInstance.GenerateInstanceRndDurability(c, minDurability, maxDurability));
                            }
                            break;
                        }
                        case KeyItem k:
                            break;
                    }
                }
            }

            return result;
        }
    }
}