using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace BuildABot
{
    /**
     * The component used to drive player attacks.
     */
    public class CombatController : MonoBehaviour
    {

        /** A reference to the player instance using this component. */
        public Character Character { get; private set; }

        public Vector2 AttackDirection { get; set; }

        [SerializeField] private AttackData storedAttack; // TODO: Remove, only use TryPerformAttack or have a labelled list
        
        [Tooltip("The layers that can be hit by attacks from this character.")]
        [SerializeField] private LayerMask targetLayers;

        [Tooltip("An event triggered before this combat controller is hit with an attack.")]
        [SerializeField] private UnityEvent<AttackData, CombatController> onPreHit;

        [Tooltip("An event triggered after this combat controller is hit with an attack.")]
        [SerializeField] private UnityEvent<AttackData, CombatController> onPostHit;

        [Tooltip("An event triggered when this combat controller kills another.")]
        [SerializeField] private UnityEvent<AttackData, CombatController> onKill;

        [Tooltip("Can this combat controller receive attacks?")]
        [SerializeField] private bool canReceiveAttacks = true;

        /** Gets the layers targeted by this controller. */
        public LayerMask TargetLayers => targetLayers;

        /** The audio source component used by this object. */
        private AudioSource _audioSource;

        /** The IEnumerator representing the current attack's coroutine. */
        private IEnumerator _currentAttackCoroutine;
        /** The attack currently being executed. */
        private AttackData _currentAttack;
        /** The hits generated by the current attack. */
        private List<Character> _currentHits;
        /** The current on finish action. */
        private Action<List<Character>> _currentOnFinish;
        /** The current on cancel action. */
        private Action<List<Character>> _currentOnCancel;

        /** the combat controller currently attacking this controller. */
        public CombatController CurrentAttacker { get; private set; }

        /** The animator used by this object. */
        private Animator _anim;

        /** The set of valid parameters for the associated animator. */
        private HashSet<string> _animValidParameters;
        
        /** An event triggered before this combat controller is hit with an attack. */
        public event UnityAction<AttackData, CombatController> OnPreHit
        {
            add => onPreHit.AddListener(value);
            remove => onPreHit.RemoveListener(value);
        }
        
        /** An event triggered after this combat controller is hit with an attack. */
        public event UnityAction<AttackData, CombatController> OnPostHit
        {
            add => onPostHit.AddListener(value);
            remove => onPostHit.RemoveListener(value);
        }
        
        /** An event triggered when this combat controller kills another. Subscribers receive the killing attack and the killed controller. */
        public event UnityAction<AttackData, CombatController> OnKill
        {
            add => onKill.AddListener(value);
            remove => onKill.RemoveListener(value);
        }

        // Start is called before the first frame update
        protected void Start()
        {
            _audioSource = GetComponent<AudioSource>();
            Character = GetComponent<Character>();

            _animValidParameters = new HashSet<string>();
            if (TryGetComponent(out _anim) && _anim.runtimeAnimatorController != null)
            {
                // Cache the parameters that the animator has for later checks
                foreach (AnimatorControllerParameter param in _anim.parameters)
                {
                    _animValidParameters.Add(param.name);
                }
            }
        }

        /**
         * Checks whether the animator parameter cache contains the provided parameter.
         * <param name="parameter">The parameter name to check for.</param>
         * <returns>True if the parameter exists.</returns>
         */
        protected bool AnimatorHasParameter(string parameter)
        {
            return _animValidParameters?.Contains(parameter) ?? false;
        }

        public void DoStoredAttack()
        {
            TryPerformAttack(storedAttack);
        }

        /**
         * Performs the specified attack.
         * <param name="attack">The attack to execute.</param>
         * <param name="onProgress">An optional function to call as the attack progresses.</param>
         * <param name="onFinish">An optional function to call when this attack finishes.</param>
         * <param name="onCancel">An optional function to call if this attack is cancelled.</param>
         * <returns>True if the attack could be started.</returns>
         */
        public bool TryPerformAttack(AttackData attack, Action<float> onProgress = null, Action<List<Character>> onFinish = null, Action<List<Character>> onCancel = null)
        {
            if (null != _currentAttack) return false;
            if (null == attack) return false;
            _currentAttack = attack;
            _currentHits = new List<Character>();
            _currentOnFinish = onFinish;
            _currentOnCancel = onCancel;
            _currentAttackCoroutine = attack.Execute(this, _currentHits,
                progress =>
                {
                    // Play the progress attack sound
                    if (_audioSource != null && attack.ProgressSound != null)
                        _audioSource.PlayOneShot(attack.ProgressSound);
                    onProgress?.Invoke(progress);
                },
                OnFinishAttack);
            
            // Play the animation if there is an animator attached that supports the trigger
            if (_anim != null && _anim.runtimeAnimatorController != null && AnimatorHasParameter(attack.AnimationTriggerName))
                _anim.SetTrigger(attack.AnimationTriggerName);
            // Play the start attack sound
            if (_audioSource != null && attack.StartSound != null)
                _audioSource.PlayOneShot(attack.StartSound);
            return true;
        }

        /**
         * Attempts to cancel the currently executing attack if it can be interrupted.
         * <returns>True if the attack could be cancelled.</returns>
         */
        public bool TryCancelAttack()
        {
            bool canCancel = null != _currentAttack && _currentAttack.TryCancel(this, _currentAttackCoroutine);
            if (canCancel)
            {
                _currentOnCancel?.Invoke(_currentHits);
                CleanUpCurrentAttack();
            }

            return canCancel;
        }

        /**
         * Attempts to apply the provided attack to this character as if sent by the given instigator.
         * <param name="attack">The attack to apply.</param>
         * <param name="instigator">The combat controller that instigated the attack.</param>
         * <returns>True if the attack was successfully applied.</returns>
         */
        public bool TryReceiveAttack(AttackData attack, CombatController instigator)
        {
            if (attack == null || instigator == null || !canReceiveAttacks || Character == null) return false;
            
            CurrentAttacker = instigator;
            onPreHit.Invoke(attack, instigator);

            void OnDeath()
            {
                instigator.onKill.Invoke(attack, this);
            }

            Character.OnDeath += OnDeath;
            
            // Apply the effects from the attack
            foreach (EffectInstance instance in attack.Effects)
            {
                Character.Attributes.ApplyEffect(instance, Character);
            }

            Character.OnDeath -= OnDeath;
            
            onPostHit.Invoke(attack, instigator);
            CurrentAttacker = null;

            return true;
        }
        
        

        /**
         * Called whenever the current attack is finished.
         */
        private void OnFinishAttack()
        {
            _currentOnFinish?.Invoke(_currentHits);
            CleanUpCurrentAttack();
        }

        /**
         * Cleans up the cache values used for the current attack.
         */
        private void CleanUpCurrentAttack()
        {
            _currentAttackCoroutine = null;
            _currentAttack = null;
            _currentHits = null;
            _currentOnFinish = null;
            _currentOnCancel = null;
        }
    }
}
