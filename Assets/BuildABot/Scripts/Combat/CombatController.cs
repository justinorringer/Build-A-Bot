using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace BuildABot
{
    /**
     * The component used to drive player attacks.
     */
    public class CombatController : MonoBehaviour
    {
        /** Size of the attack box. */
        [SerializeField] private Vector2 meleeAttackSize;

        /** Distance the attack travels. */
        [SerializeField] private float attackDist;

        /** Duration of attack in seconds. */
        [SerializeField] private int attackDuration;

        /** Distance between the character and the created attack */
        private Vector2 _offset;

        /** A reference to the player instance using this component. */
        public Character Character { get; private set; }

        [SerializeField] private List<EffectInstance> effects;

        [SerializeField] private AttackData storedAttack;

        [Tooltip("The layers that can be hit by attacks from this character.")]
        [SerializeField] private LayerMask targetLayers;

        /** Gets the layers targeted by this controller. */
        public LayerMask TargetLayers => targetLayers;

        /** The IEnumerator representing the current attack's coroutine. */
        private IEnumerator _currentAttackCoroutine;
        /** The attack currently being executed. */
        private AttackData _currentAttack;
        /** The hits generated by the current attack. */
        private List<Character> _currentHits;
        /** The current on finish action. */
        private Action<List<Character>> _currentOnFinish;
        /** The current on cancel action. */
        private Action<List<Character>> _currentOnCancel;

        // Start is called before the first frame update
        protected void Start()
        {
            _offset = new Vector2(GetComponent<Collider2D>().bounds.extents.x, 0);
            Character = GetComponent<Character>();
        }

        public void DoStoredAttack()
        {
            TryPerformAttack(storedAttack);
        }

        /**
         * Performs the specified attack.
         * <param name="attack">The attack to execute.</param>
         * <param name="onProgress">An optional function to call as the attack progresses.</param>
         * <param name="onFinish">An optional function to call when this attack finishes.</param>
         * <param name="onCancel">An optional function to call if this attack is cancelled.</param>
         * <returns>True if the attack could be started.</returns>
         */
        public bool TryPerformAttack(AttackData attack, Action<float> onProgress = null, Action<List<Character>> onFinish = null, Action<List<Character>> onCancel = null)
        {
            if (null != _currentAttack) return false;
            _currentAttack = attack;
            _currentHits = new List<Character>();
            _currentOnFinish = onFinish;
            _currentOnCancel = onCancel;
            _currentAttackCoroutine = attack.Execute(this, _currentHits, onProgress, OnFinishAttack);
            return true;
        }

        /**
         * Attempts to cancel the currently executing attack if it can be interrupted.
         * <returns>True if the attack could be cancelled.</returns>
         */
        public bool TryCancelAttack()
        {
            bool canCancel = null != _currentAttack && _currentAttack.TryCancel(this, _currentAttackCoroutine);
            if (canCancel)
            {
                _currentOnCancel?.Invoke(_currentHits);
                CleanUpCurrentAttack();
            }

            return canCancel;
        }

        /**
         * Called whenever the current attack is finished.
         */
        private void OnFinishAttack()
        {
            _currentOnFinish?.Invoke(_currentHits);
            CleanUpCurrentAttack();
        }

        /**
         * Cleans up the cache values used for the current attack.
         */
        private void CleanUpCurrentAttack()
        {
            _currentAttackCoroutine = null;
            _currentAttack = null;
            _currentHits = null;
            _currentOnFinish = null;
            _currentOnCancel = null;
        }

        /** Coroutine to perform an attack which lasts for a number of milliseconds determined by attackDuration */
        public IEnumerator Attack()
        {
            for (int i = 0; i < attackDuration; i++)
            {
                Vector2 position = transform.position;
                RaycastHit2D hitInfo = Physics2D.BoxCast(position + (_offset * Character.CharacterMovement.Facing),
                    meleeAttackSize, 0, Character.CharacterMovement.Facing, attackDist, LayerMask.GetMask("Enemy"));
                
                Debug.DrawRay(position + (_offset * Character.CharacterMovement.Facing), Character.CharacterMovement.Facing * attackDist, Color.red, 1.0f);
                
                if (hitInfo) {
                    GameObject hitObj = hitInfo.collider.gameObject;

                    // Get the other character hit
                    Character other = hitObj.GetComponent<Character>();
                    if (other != Character && null != other)
                    {
                        foreach (EffectInstance instance in effects)
                        {
                            other.Attributes.ApplyEffect(instance, other);
                        }
                    }

                    yield break;
                }
                yield return new WaitForSeconds(.001f);
            }
        }
    }
}
